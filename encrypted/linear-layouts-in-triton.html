<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ac5c8642299abbf1cba5f6f77067ca2cfe3191bb1b44a9bdb26ee7f99fdf3fd995b0f7ef6090508a552f7f4d398fe82fca0df5508f05974ecab5c728f6cf736bf4aa784f166285b4d5b1270de130c3361fb9f89395874b4044ca12168151b37f9dcd550a72cb241f61d66668f534d5f9910bd2cbb53a7c686bb9d947ff6405aad0dbd500122116ddcfafd7afcc361ef2624351e5a518508399c4165ecf2cbcc935f464a6879e163454a714af9d6d5eda5e72d7e767968e7ee35fe51704bb9aafd365a74575c2144062379303f936e4e6b50f9bfc3944a48df923851f67bbc9ef9e7e4ecb6acfd35fedcf76eb62214e2c07519e45aa864e2ca23bf55d54efde2590ea3ebf4b14479feb286ed7178d516e3132b44e5ebd4bccf91b086f87fe9b517a5c97095a8a01fe26d616b6073991ac3dc9a535cbe99730d3a3a138c392f701cc9bb888882ce2627e21362eda71b7241d5053b1f95839c87cf7bf257498536f8adc3337461a48f2f95920b3e850c502e4aaab03c4fecf2d3666971364f8e32333b454893f6f08aa6fc8668f6fdd70b9fa1a8f3b9b20fc23917129333ced4c8908145047154532037f43643129013fc2abbd7ea7f05167251355d591975f124c673852fc4a7b8099d14c232fc5f7c40ca6d215c6a468c8629c24cdd5d32db5ba70924a0ec20329597c0127f4f5fb8f54bf2b9379d8ed65a6ed24f6ee942fcfe944c1259aa7683c16e5bbd5f8477c1b9c97b58000402a76d4d78f76abf63dea7401969cb2b8a79e55550f25c295cca652a7adeeb9ead2633a72f8d5fa1d2ec021c2ac1e1475a55f857a3f16d5dce34e10c487fafe6f4bdbd45b4197b9eeb9426b0082517fac86c26d5181258991ba4d8378a5c283a5f8c965f3f039236f271458c7a0424c80eb6f7ac075db9b9867c834fd8b55bcebf8a5e71484995d91f11b93c668d67bd9c08bebfea23b884cdf0fe9b56efbb6b03d5002c0e07f95072bfeb2d81ac10cf31e2afe5f52080daa199d4c16dcbd8df8cec7827c5df1114a22e31025dbacf297ae9f167310d974afe1e348ce093d61b891ca03bac716e8cce206e1f76dc1434484afd1bf315492f3c2114906979684184140fd59b915e5227b78e83915193776ac50bd8437d3a2158543b24b6c143fa1333843a365faf3384e158011e2eca36db49ffce3ddf85892ecc0745d4dda2d67334e5b1c0d1adccdcf3a7943853039cc0149a528054ef1c43fc633dbee0fe00666f37b0ed977ac1233a284332e73983d6c570a90823319b0acac59f8b64349536225453768646b33d19756acb5ce91518cd79153e3d4d2de9c182f1bdcb3573c6fe95f481bcda220700f6f9b13975b277bb589fa3182ce6326bb322bb3d6424aa0674dd7071f021d58bac1c531a361cccc9f974e56ec40ef06ba83f3d2a8e3d96defc187962f08aed995305e6428e8e4342731e89cdfe9800e638c74a9e1b83c838227b22f0c8820ef83fa91d3be44ff287a809dd0ef31adf3f90fe185456e4b236a10a0a76bfafef612e5b2d15b30c3c9aeefb5f0790404c724598043d257817a253df2dfc797ecfc473a6a264ca1ba3a9c78d4d564b1b52ff374b14f7af7b9e1f4126c3583bbe079a4d40d268ad29ec8b13335205e9ddc7e3162d07f26f12188cb6156a51062a0e5d21caa0d99818352ae7f3bd048a3c8ce32f3108953c394ee5700c85aac71bbb661eb7c47b6a80dc894be216b951a361033c72d13fce46aaf1f8874d03fc3f313f853e803f73cfc0bd0e278ed5383e8be01cfeae1e92a89fbbc13a243787ea9ab5dbaeea6ada6bbaa68988c8f7405170fd1a26bc567fdb3ceb869e46cefe6bd46584c0e53a053d44c9d07f6126e2caa164b894a125cb688d60e788284bdbb689c0a60c44a5e8a5347ecb383071f6e9eaf0aacd5f86391e0383713d2da29b9c4c79b11352607db222a4df4aa711ec3c11f9e1ff453740086d2ef4bbac70af972a0b496689d81d8301bf3d9ded7c2d24aa695c96a659929c69fc6525ca07cfc66dabc8460a5b92aec034a28270672829f98f2f018cdcfb55f132290e3574856b26537693c219bc508b794c851936cdececb22f1cabc3f0eee3a171d752363728858a0d2605a66a5b10b0f2b9561c0754bcc96804bd051c44e56851302b35755a98a733f6ed5ca665850a9d0c3acf91d051132898999399064c67a820ee922deacdcbdf1d546f428b86eedc5f7d72af6af79205b8f0c118b47576e74b8469ae8849be651c84c61b3a7082fb3b5b5f15d942b1eb700ac7b3a50c4b67b90e8891457a37e4e3e3d83f52561cc74fa4043573e97ba9d45425c4eeaddbee0e37e518c65d256ffa82dbe9763eaebc79a200d8e00c991716850f8d0294ffbe54e57496d7640d964059c8407d5a1083815d137365e3ebbff396c1dcecda097b07c6827207e683e777abd39e8aeb7751c55cdde1f2f7ffc1f7f0fca453232bf24e6501d81184c06844d8582f22f0dfd0274dc51ed11dc868e676fbc148d621d32cae73b5c1d7b59f382eecad9902093982d4ad2a3b58b21e339d4ee3f70e577570e0b2eec443920e2822282e8355431ba643af3844316e502cec23a306ae53dfd34e8cb936cf1973a7aa0de80380c5114e6c0ec25b6d407e7462d7c036906a2267c88ac62f5dbbd1b5d14f0c00a5630f7ebca633067905ff6cec56a5e36dc138dd0ec2ef741540bc341def1415c1bb0dd9e2b51532330b2c7b049c908274170dbdc0533c5e5c73c34986f1bd09e68655a5d23032c75c99202d48178aa8e51a72306fd734c526c596d509064133ee86c78dfd9114a51736eae53e72523813c408fb7a428939cfbd26202911c4d17cb80b3d52cc766b9b3f165f7d26f70623c0654eef4a3667969c85fe7848c4c434c99363babe34125d050496f760b2fe7545443c8ffb977c946c1db23bbacddb7d0e5291d61ca4aa831f8c00b76b74102c734e94ac065f3fd4c42cdf65450902b606470e2a335e43c56b0009595a272c24d13d6125a47a06e83b763166f813aece87eb3558bee800700c6182a35504465562b283021c9764a853d5fecfe3d5b70a36f125bd87798c9ef48fd5958acfc06461a1fd3967ea928d7fe787d2cbc74ad3f3730d3ec9ef683f033a7e7077b9da4814deedf6a072fe1eec71e7d23c8e175280696465bedaca9469449d66511dd3f62f66f13009edbcc0fb6e0b18fd7bbf195f18e546ad8039ab2ab6553c3db32771e46c6e558d49bbecffa869925dc54a5ab8fedf409a20bc31116db360395ca27193140bb1a6d4188da9dc386d75460152da249e9a94869e188d7f25fd5a5dda9a97ec2f8ff898147a9af4b788b916b04e78f2024ea8893e1a2cafa8bd1875f7a35a32f8ab1794aeae3e1eb525dbda9a6fa0181d42d2aa94022a79c94fea9e772b1217a4eff544883fcb12c5e83305dc14175824d90dd2a0a7d57c8a97a335a53de02eca0bee4e3f8c8747b221daaaa4c6e29c9b31a3ce60b91c2ec93ead0adeb711079d7fefb8172810113e6f12276f3e65182b99d54712798042419443c1e684d5efc6569cc0d0e34542f72e3f39ad822a030a6d1e488277d66da6483554fafb4d0d0ccfdf5fefe0a18ab0cd4894d668bcba7e612b2365a06fa02dd790f0151dcc24d0896c042c66d628818a73d1e84637c6f5d33f3421c5ca341395fbcdf6878878275c6472d708bf48182727916b760ae54e8fe0c1cf015125fd7953ee230e8c1bce505b7427b995d4572a6ad6443b4449092fa744517b6876fd9327be31c40a9ca302ee01480b1b9ce5c69f96376fdba8929e9e60dfd734356618c3e61082f13afec7a695bf02279ecbbb2c7c0edf70b4a930fe0f5422de150f7f8a8f60c60b4882513ea4d56d254358ba099966d2a286fc03de36e4c989351b99d54a05420d79707f32fac19e378748eb74fcb95e30caeb8cc5067045ba3bdc9c29c39bd43ae8dc470a08d1c39e35b62da4c8210cc6f3244a6451c272ac2d4c4df4046672dd94f03d353f6d8c888ae9f041d4505adb14e4ead3aabd50c9472276579c674de23459d61963587f5f21c9fa3e8a3d6ac72333c18baf4e9b32c06ee7d19469a10ea8dc7aa053406b0fc728ac41b97264cd553c902af02b8f935557287ac93dc39653302e372a2772878f9c5d75784846e22c268869dd9a7aa446123e785660dbc16ce9f659d2107d8a0237f063d403608611b9129a764c399cd298b5d9706a32cafb00aec8d35a9a256c839e903eb766a82d7acf2482ee3de57aabffa625a730c9e5bf25b371de4a8ac95cd277fbcc647cb3e4121f0d7a0f203ad4e79b654035915b539e0bdbc42d253beff82da714e965e3ecd65c768e34bfbf746f0d4ac1a60937fbfea1615f87cf8bb9d73413e3895d21d816f2fca30142db79ab3606c664e04011e55bb4e6463ca8b282ab83f61ce05b8c9ecf2251c0efc0da406ed7e203f19b06b365b9ab5ad9f1887490e9f7824c012b6b2cb6a0dfa8cc3aeb58fdb9feeb2dd01a4e290ab5b812b18379c3e2421c3b99ad0d90be86ccc3de9ba4b522efa7626105acb618b6dd83f4f7f5dd06141bd2aa53afd3de6b01dc896f5cbfb989fba0668961e5bba8e886e90a18d0acf01f10cf012c15ba7fd231abbf2ee006ead9fd728b9ef7a1cad8fe62b82a192646723af43e33645550e6c2e403b69beb2c6f931a8a3aed352b0e5eb1dac1cb221bd219024533cc6f3d6c784faa70cdf2afa67cd9a8faed79c8ee2310b6037a76efded27633285051413cae6ff58055672279032774a7d77ac39c812a3688f4a27fe429fe9746592c88d5c279611592167337b1529b6272bf4757adc6b2ea0f8bf4d7d73aa80bf0a9929713366606831ed2f3958b9e2fc45bc1cc76628932b433edcc2805c73dd3e706868fb69e011fe6586e1a208d48ac3c0396fab1520e91e137ac394b42fe04a1bada7252bd1ab927ac1b53a00b12a66f9e43b21d37694f600120709f631058d53f53e04d736daa2370ad91f8fa5ab6c316dc005abccc1a54c27b72b56901a183ed378fef1b2689171037e2c976bc96067f1af5045f68f7acd9f153038d9372cb55e8217bede801886efa2eeafe975bf8e30066412228bbe85ffc38416d69f6ed80f697fee65f99b0a172e6ed6901a1fd9774495924fbfc4d400f0a4371cae601a15811bea5b6a96138a980c568ffc6c9d3a90eb64c5755c0c8fd57d03eba21faa2262a3dd1d591e9ff97e296e8169d9389dd3d52c6c129396bb8b8eeba7d3773eea47c5012acd538ae74f83b1083ff9aa90ffa433567e73836e2b10fb2e9d5bffd931c083e15985de5a9e0d1f833823d534819de176c738cc15de5c5b571e2253e16db398c10a8d81c41a07cd55615e7b4f76b92151e4f3dd6493037f29a8282903f93a50ea0f0700760d3fd48e4e49482ae4221dca803e5f647691d6d51cd67e4c6bb09647ce91cf4eb786f02936675676e479fe51097bc2730a11ae69fe378362746af597afaf0193a988c2f3f6244dddb565b308a8a7a083755c0739174805560d5d51bef74e48c77546a9ea49d3f305b93f068695898af74540f1ee41cb645d4fb52b7f1a89a8adf773f2554abe30937165d1fa1be76680c32846f8be36ef31b1188fb4ec54162c2bb6a641c66475265c0e3dcf50d273caf8d8b7683c78e38dec5d47df6334bde357ca9628ddf8dbf17f427506861a1a90d5892e8b0147e8fc03f587675bfab18db257ca4a760d026325400b5aecc38e8722096590b3721e65f81d86c737c5de018876f95191fbc037317bb4ab744bd5c153e6e2a9c03a222347ddd9e995b58ded8056a64866ebee4d8928afda886f0347d004df914b8d697db920800ca9c37f6f157f121cfa1b80baa762641a8ffdb1db25d16a386f5ca440fefcf65bae0b49f21c9855da02ffbdeb00aa6e63cd20b933f7193ca313d88238ee2024d735d9067b190c7cac4d74e7ed74329bd409629f65143d2ecfee293e98bab1bf5416fa385ccd4c77ff84ef7657ac259ebb4693263705b8dbcb839e447d3b4412ebd7e01f5ca40a32133f76b5ad740ece7984ec4fbc6497ab00032f32d9224b9dbd663fcb023a53af09b7ba48ea23fe962cef43c9edcae0d317a27e3aea866f49ea733b16caf2c8234ff909e7fc72a8e0830da8ccc00195be157aa98573c57530b787fd79d9d6c48363c42e9e89b746e577cbb86dc3773f5af516e5416d7d1b62d5453cf333bf9918855311d2ea538a86e55b619d95476e69ae4a8dddec994d2e3b6c7cc09afb89339ab7c73abaa701919d9d636adb69c64bce5873dbdcf8025dba318079037e111bc178991a81937d480efc5be4758c4d2c5e1c5ef23617f3dc56fccd91864d5c6c28a605adb5b989245a2af87a4d0faf0b00066f7e862b8de9cc42ae60c0aeb90f33772eb5de83a1428cbdcc139138dd73d2ffecc6b7622e84df51f3e828c0d8d985f5377e4ec4968ba6dcf7c5f9cf786a1809b81959cc4c081b114a1e9ac99e64ecdcd2c878b8ca27d0a7b9683f7521c2796615b112e1080d3243aeb8491dc1886e61d276fb1302d0cbbe9ef44239edd0868f23ba2eee3652ec00f42385b51040773f28e7cf93b213c2392e26bd4e50ff12110698b6cbc273d3a3e964042ae99fff5e923ee9fa1dfe9aa6f3e62ebec9fd36987977e75b22b002a0ccf7c178626cce4a10c6af893f47e5bf259dd623c8592ef2eca07c21462384aedb9ded9c55e23f7b3cdd388bca112a6ce7d2ccbd653d88824009fdd7d67ceb3f52e853c0d5592429a2674566e914d6e7cdb8db70568258077cbe5b55ea459b6fa44fc73ecaf582015245be00b4e978eff8232ac97b468aa5f9af10f2d1b6ec0758b4722b866d822d61d50da5d0e678c4259f9ab9d843a359e781e8addb93dfd939563048c355c1f3f25b50895293b0d8c768897aef30ac504e31c0889cf8ada3d6a211a5a25595d4ff30d74c570fc730853e3ca1889b457ecf40679053678b27969eeaf2e5b0a12d7bd34e28169598cf1c08ff32ca8494af7ec0b4f82e8b44d6fc4faa9c4f3c8caa4fb2b49091e3cca1a3c2c54edcd3de8e1e686d40f7ae432248d65552a91d30031c198b5e9cfadb02dce1ebb0c1b42316e6d4b87580914c768536022c53a2635e43a92dc1433fa4c536e14ae6c6e435f4f10f173c11e70624f6a24553c763ec0e6073e2bc04ab070945e13af680dd531edd37078cf1d772fc4898f8d83aad7e6f2ece2a45f64bac1fdff2d2515e7a291accee12c790d27e6a50c7f39fa5a807e583ac8bffacc0c9d3f4ebce405a1a6d85c3a452fc358a59d5f2776414dcaecc7cac6a3a6bae0491df16d300a63ef5db0ffd1368431fe93a0a95d130627cc9b0ed9322ddc5d04166d4ab03c5ca08a613b642fb5eb09b9957130ab00d7b82e12276d2dc67e129d788da2f3d8bf9246dd870bc8e0063cb4f5280390291d43a79e64db36a3edbac2f4afb38ea6cbae53d350b69894803d5ad03fb80fea2fc18929192079ee122cfa0303ae492dd2e8bd768e07356604de51bf30842c31832ef4065b82c3ba2ee7eb7ebcd406776e119d53cbc91f894e2a0025c79b33328ee58fd2cba1635cc2f3e61bd4d52dd3f4e958293582a8d6809dc23997852688bdcd93482666f4b4f7fb1e8e9736a2fcc074757dc0ce7dcdee4d802560ec505082b252b2036af82b533f43e4ee884960ebaec19f4fb62011dcccf4d6bf96bb1103529667a65f7bec0d218e8f4971513833dc13074555aa9512c885d6b88ff5f2ae57b6b1bc569b584ae22167bf5e9827d54c0f2d2437a2a1b40980a32be83533ce7bd3b2b0979be678b4d9992e6579f7981c89877854393b0ebeab5819ceab1a9886ede2829a449dd3ffd27f576e3aa7949435a30bd6885b45c486709f6b013f1998ed0383259659d4b33ea876218010ff008ebb21cf7fac613b18a8ebfb152bc2aec682e3d3fcd061ea008da85672968e950f193a7d3cd230a3ed3b7603b94156c236d6454317ec458f4bc701e7938da1ea47bf60e8302edff53976bdc214f249a99332e241e890fc50624823ebdf9acb49cd0bd0be0a00aa925abccdb70de3c129318d95fe537611a451ec30d16f8ca36286d5cd1d9b8b133fc2c888bcad6653a93c04926466fbb19e420d2a2353acc13c490f825d52fb45b4a9eae5bfc3605c252cef7b8df28930ea7c4bcaecdd8f27c4f78f7dba9cc58b1f010f9d01414ff5b48f239ed1ce1b23a8d0da95042947b92f539e649ce47a1af03f86b060f509ab741b7ba1a2e05d4ca76d28fc15683fe0e157303164c49d59fb278e718ad62fee4c63f91c4536ea2de3482645da018b1b4a33a0356e2d8880c8da95a6a77b3cb34384ae085304c6feaa7cb8a5270d96ebcda5cd6def48ac672ac3f441fba9d01965d59fc2d44f0e0cbc7593e1d4b837e69ac9649e64bb55e95c4e6a70e39354c35d0c5cbad75c2bce36909fe3e452b2c87a03028d1c27caf13e438c98274cc7c4fd7dee8b72a28174780082eec65c912e31b6bf10e641ea647cf903457ecf93663af5b0b92e627897111843f01fa6455648efc37beb41b78470c8142e7293535e898a5369ed040b68eced5f5ae33f2277e7f7119342807e41a031279da7f7c89510eb57c28fe9f67236ebcaf0aaded29c9101cb60e78d99b6b006b09a69432b68d24a5265879c3da39d75f1bd11298b858cf570a1bb581027d6baa9f4676a380526745b9db8ce8aa3582e319f7e302e5ba9ab1c67452bcd384b323a686eaa27284757c77950d821fbc5c9cb9ad4a2570d9838f33b08dfa8ebc7b2e952c8bd8722987a2c8d71f6b7e40e34dd635e12e5a4bec5a4f6d2b3ec27f0fc885f6535f48653ac780f21742c582b3bb77d3c33960d4fcbc37cde82c090d21c17e8a672f91b523e0e8481b72169b73c468e1a158c27be493755019b1ac4b213c14df62e35e59dfab08fd717223bd15138c4ceb823b3f9a50cab5aeb8296489d224d72b3220824f77491c8998bf112b88c1e64fe3182f93e989109a7af9c0f83e31b7534ccee4104f2eaace0e94e3a575ba030db1667a0c70a84dbc2a0054fd0b63248b431245e8a1450c35d1f81f9916162742dccc84ee3fa9d83426d710ee737da618813fb9c3cb792118071eca21d0b3ccb0ef87f3ce7e0093d32ff95e4d7efc251dba033ce2636096449b03ffd8dbea90f505638b17a1953bb14585e13c8181e027bbb684e3e83f09523203ed3afaf1f012b0671d2476a4e23c5281b0f86a3cc9059ec367b1b76b869eb37cefb29b5122f0620f02c5147bd9589166d14cea16c37c8f1b16cff8f4edc376b5c6035ff09723d199703a07dc6ee6cb5ef6a51cacc69c1ea5cb09d3f87768c5d66424a9dd3d25f3c0e527ecf4b65f5a3cf235c6fdee4a371c3af73594683f24ffa5695fd2ba325cb809e83d168ce325158085c19f8ae2a0c09a112c874727082be0ce156e9cd31ad00f24298067647afa7768cfdcf4b3c80d8ede4f106e62cd200cbe6b2d03c8ebd7a5046d97b7ad7b0d9208cf6821f4e9e7c63df8afa64aa977916142049c29c2cde50314a5b66d2e65bc462d359240cc25f6193713595f8690e5885c7c14d2df78189b575a9b66a3ae99cfa4aa8ef0b4a85ebbaf3115494ed721b619807ac44bf8ab4b84151d8dca2099a4d3b449654138e23a5c72cc623c3a7e03736f099a7bca068130f0b86214bc9aef27d042b815af5bad2727163175e3491d5efac9d8601fce236712d677bedcb5f7d594c05d96af536101c28b5c4ab040581c898828c18c915998ffc8aa88b184fffff5835706db7db9953a0e0d95987f6f68b25a77e8e1b08294f1f0cccb9ebea4ccb274fb09e2f0f80a88b6624a2d3f2c23448e3ca1c44dfd7663106026683c5e0d40b3e7a7f3f38ae2a6259fd2ef5caf71e1af36a313cc3c24602c014618fce9f1ad903803e998b95bc4bb481d1d1ce396c7b2a57b574bf91ac02a29c766ec2c37772a2eafa4888bb6a24715a82ed71c01fa666395c6ddde7dc07540a3ee19009b4a3e42a5e056503f8b32be52a8d9c1dc3a9792321b8e1fd35786504d60761f35537e3831521195945b09435c679e59e0c948c88dd04de85fde19cadf09be658f27532a4662f8f6b0a4e50566813399e6ae956be5307d56a38075563a3681a8d05018201903e9204168aae7701c07ee9f890fec979f04acfef2e47dff71c28418e0c080ba9e233ca222a7cf74fb74814043529491a03a37a7c020957774139909a90dda88c9fde7a4f314cb74dd2b16abd17179662e4deb91a89f153c1a6cea1400ca6885c56946e6694ca73732d29c6413b6c4d5ac5fb19374d752c36d7317b7b40a442ceb6d6778bb417cbd10a8d5807c00bfe73357b312f1fe6d4cc36a4eb4a60e6eeeadef40c7f58f45fe89a2c44af170d24a5e7bbf38ddc999c9f885f09b4008903e465479484044703db3bc8329ceeb0cd73dde711bec242e194aa690b43d5fa7eba29d571462526e7807073153efb2bcd733bf5261cfcca777e4a6a345d36ee52d6827e247deb3cf64b85bff080816dfe561f8df9517734f2084b968fe0d763ca2754370ffddc38908d999d5dcc7c280ece8b9eb1b5dd2d2f5bab031a2eb35e1d8f5f190737cc1601ee92f7383b19bf8011aba7d9966a945b32abc0b60c35aaec1e6560d7f142cf1a5e1b286f252b85aaf58e6a72d8bbc0011c090e780d07bab2c0573d9a2e021de376125de10f33b580e4657ab58bc56963a7937d46f0013933a527bab966087d0b9c5aaea58ad8d43301372486d0238717b7399c8f0630e49cdbfa404fb85330c933dd38a4e89d0a604c4961940520beb980ea29222657943bd28afcaf5a3240021a08395863a48f9274341b52a4b36e3e3c813fb8e26071a360938df5e61f3c1f224583a43f61b3e76fd6ea888e10789c6165f6a621801f47defb7e33bda9f3561dbe1f4ee7deb3fc215d7cd111fb6c3cafad05a4489b225323a16778ef61df6761fd55a0d30b809ede39f4004f0f6d1a8ef5fd061cff44453714a85a5541e467bbc9d6d7526ee1c85998ec2b12b66a499c6e61ba7e3f85fb313951d72a54ec7fb5b647e6e8bb2e13ef3e2cf32c5c54ed3818929320da8d0433b74bbc638dc9f726ee61c6d5f7296bd7cc847b622d39bf56d8c5fe5e41e00a5edc682a88224b4c007c46f6e6f851b792522dbd05c9deea3eadc58413ba7de73828b7a6271e8959166266ea558cd2c9818a69fcdec6e4b74c43885d8619b4a2f81629d52ead168d715c4b15d9b240377f3437b300410d490d7ff2283b0403ed15013b875190fa0b1b5541aaf23eb07d4b3b373862a857e36717c19c098246031691e5f893a9ffad9a6b3d5b41dab6b0d61fc97217d0f864d22ec18663b481e462c64c2f4385d3d7f50c9928390de07915241377ac18171dc9ce3d03382245f0d09a6f0e085e37f08de712606ff9513da34b964bed3e7a506a47f1a3a3ac7f96d1649a9a9dd410de2276529f24de55bb0dd8e4bc7eb4442be563d7fb087e788f49efea529cc7e0b980ea4cac6ca302b9a228d706fbd8ef680464465a841cf8856e100be3a6ec770e8d60ab3eb3c84a0bc177577abee400b8cca30714be641b1e2578c36e40dad22395346b101c25388110cbef2c2e91d79dc68778f402fb09c862e4314d96d6e1fba771d6da09696544a064581555592ee6b170c92b9dfcd4fffccd7e7ef8a2201f7a84bf33d322d6d69d3bd16938a93a139fa6385d0243193946897c5f495ba5c0cb6dc8249aa725c0647e794bc283f8eab6f5471f83bb43ea6b6d5eb75e2fa66e23ccc52cd78b26d76a3982e40e36f73e357eafbca46310d8395a00ef769ba85e957ae5787f59e3a9ba5a8bab75af4e0ab3d137d6c5dc9b05483514b862ed22141ecf1560fc3cd313c18163a5c6d10778cb5dac2f0c46e8e5485df489a6a47c24cc529d8b4aaaf5bae2fd9e34a3fea097c6b60792f776bb2c3fa4d27d7323b2a8786bbc643965b3e4863123d6f5729f4e6c5424d7be938b6d63b90b8d2a6c852621f797d249b4805563ce2f9444879170700e9c7b51048d9a424dc829ab1bb7c94a86c1e14203e2618c7178addac3bb785a8087d6e238850f2cc644b1c8c7ef8caca3cfea8c5348ed1fb07db0257ed519fe3726238508b4a29f268b56c146d25b06c528fc22b1f5ee9cac0d61d9a554dbed728e47a0ad253ae8596596501a2a91b3efeb8ac2e69e9b18f3a8f7e3af425bbf478b22859766bfd4fb395416cf6112f375c65cd181ea2eecc532e5fb7f98e2f5f1183024b6988560125725db9b4efd7e00359d209f38583f6d44f28e4728b1040fd996ca9695a139f2bd63e85eedf5055fa20fad3dfe84e9890b0fc08b8f96f543a151d2d7e9979d0488fee42da96ee5964b1078907dae8f8e6674706756122fe96edfe9efe24a61f80c2165de694face540729894079fa6bb28af07ce9fd417692f6d8ce3ca6e220061ad4560d662528a3e61ecb18d0feb9d1df936802ba7293a4f4a1f8a70868b6adc85a8e9315c9f4fe33e238c44499459f63684f9d381d5b7ca968be9cec48515840c5ef54fff4123513f963334526ae04b772ae408a0b411563979696a6665b851a617e450a39c0717d59496db11cef56c60ffa3e6b7a85cab3059ce2d3ed051d0c455bd3e8c4f0978e5e979a30304eccb38f290c83c771165b443e1f8ab603f61d07c21dfed57d6c73b9d0d501bd165341f4972f8f85928234a426f16e8582294cfc9c50144544468d1877f6643d240c3b841292bbb524e776b79b26211584d6a7cd9659af8939cc3e6d15f80130e527f94e14672599d560c0e4b72d43c02deb2ba88944b43fbadfe1068d81e785970ca5cf59316665ebc95636dc302e53bb82d6f2ef15f67db8b5aaac4f66cfde633eeab5db5064e237377352c98db2f4d0f2ab3ea37bb730ee8087024c93660a7a787aa8b729def42d6d34376d295fd9f9a7a2f1780eb17f284a2a789a8481dd6af5a5788a85919116528bb9f69e454f181bf65b21c671a8a1590ca92069138b53cc18c78fd4c855ac1ffd7c7567246e3207b856d7a74b31dd5fea797e04b5312942d1bf3f0197147035f4365ac23bbbe45765b7c526b5d701e7fd0172e129edccf854faa0b5cbd07cdb3a2632f2f3d13e5a37d0e2d9fa9e05e5f4aac6044edf24b678941d6b5b4a4a7d7a7296916b849c697039840210f9f476d7d786c870796dee5ad9d69448e4d21927fe96f7f2797cc5e163998f6785ad018adf08abef3aff7f6eabb25a049b69b1b596ef862a854782459cc69e217ac552a17ebbf235310b1e4eea2e316924147974994b67a9f121ec283e25804851daa7c27b67826c0fc6f32280fc0ea7ca874ff6535ea7a6bd2474183d43a7780ef168ef19ac342c40b249b161934f67b42afc151fb6455507e2dd98f0907ff35532e62b90a15f2da39efa3d0774953071feb465c5f01d9e58a42dd80ae71bf32087ed4c50196b191faac3f00d668f0c87eaf73ff818eab7a1af2c5680059a6ff4f373027943643eee36b77df0b254f9be067f5d549fa4dff6136f28e1a98b85311c00eb00e5471a1d09f9d3b5d526c377345dfa16dbddd8783b8b1bd6e9be8a444b34d0ac7a9e32dac895074558cb31f72230e1eb316e439fa6f0441a54d58ed310e119fc293fac7dbd88623c0673ce37955b653e414590fb08c75e20a7849a82b80a62d4e021a266fe8df446512c766c1d5c85e8c112ebb6f3a72df0dafc4ee73c3d984b2f52718cb4f1ce8e384224fe2eec0385bc5856c425dc776928185e6d5e7facb2a7b14a61fd6cf976829d1ae2654efc1af63525ba7eaf6c854d411204eb8ef323d41e8774ca2fdcf41b09570a8216779de83682c47aa2ef77f30c3c86b3dbeff349245e490288f60da9bee80559ad31c00a51fcb5e48ae8c2490e6ae9feb85bd983442924cd649b0e60a7dc7844f041230f26764d729b3f6a68b39385ed1ee7c1736c0eb09cad8eb4d4d3484cd56c9e96d9dfb4c4610b576175a2a9786589ba2a9436adf3430aa0bcd2ddf17666e98e496cd816d3c7405aa07821fe21dd0c94b5b5fecdf9d0c4db36d77321f5c8c16570aac81abfb30ebf3186bcb2b56bf6a6972f1ab52739fdc550861ae95042d7a1c410ed3d86fccbb1265e34e483a6926ed2f0848e929955120f921c92d3728e4db0e80174b588802389167c03a6fa7b2a756f7e46c49befae41d849b8ceafb8a73bb4903508a272272ba2331453fa69142135be968af7a0ab364d7231cbf59176d8c54d95aecedb1f3f314c010e8a0fb7fa0225243c4d1e26f9de5afd2414c3aa600f90d9851bf22a9ea3cf458ef6195ad1c6988394597e1896f05453ad1ab8395a61c4d1f92b5caca91989997ab6b8dccae180581316d3a4c60c0d9826cbae3a35e83b8aafae7e7e2fdaac80c0f247dd32b9870fa89356db64391a501aa4c83434e85874eaab205e4b2702e3e350577229a1079cce6e5f37dd8f044c704a8de01da6d673b08468fa5826aaedf81ceaf17c60ca1f01eeb051cca2f7a27d8b8f2ee08dc3bfb8783de7ba44ce0e01ba0426560f47a8597fe875ddb7af71c87651e42cf814bd07e38f9ff12cd1f5d2e3ecacb4fadd9e7e7f9c41eb555b73b9743a1e57c8900d8ddfc470fd4526d92b67aa51777891b5b6796707aaf3223fd832a3e8853b147e3e8ce2a497856ae23fe761a2e9bd2fe6ec8b4362259d4901e9b53cb7837c099ed456f89cb08c86f88f1bf6508fe53af14156a79cde22f52ed4d537be8061476d090f0025d178f375554a62e1e8821edd7b7dbc03f548b3a9846ae99813d06432266e2e27c06ed120c678fb7641a8a5a4742d56ade6739c4bfeb9dd2c222263666ff9053d490f54057e37c2d98265b85ccea8fa979cbccc5d5994567a162b0ddcb2e496e7fa1f1d2b96e3e1ad361664fcdf76a572908abf6a12ea1396ea30091e658a42d118358f3479e970ea9654e0fc3658376d2ed6772619a52d8e496cc37f0d62ead48290b2d879aa68066573037a2a9cfe08dc10c1a374a3d4a2a646e3d0420fb86492fbaa390f49bee40d5d3d7df24d4eb5aa4347ec79c29093327386ba20332c73920aac53a0540ff5cf004f161c4e961e9f75734f4a0045660040a742320ac6cbd45086dae8a8e6c4d0491171a5ff874e2ef82097a10d1557f59c5e85ca6e8c06b2f49b29a7afe8226bb8da43847b196d2ad76e1ba3430c003f82192c2ae86618ef27c45e96fc4f2575a35d968edb3fdc9212349b87274a2a574214363e2d60d339e7af8d2216f272ef8e3e35edceee16af149ba30a19d54fd601168b7e946b2e05677166c1f19d84da58cfd01a959f2b68e539d433f112399cc3de073c43efa8eabe0452d0a2ed422d155632c6156e5b772b7ce9edce7ccb886553cad2fd465634f4e7f3443eea244d860bc8ab7158a1b2da1f3d544da02a3111f51f5cfc7dde94624e2d60a9e2044ee57f3acd9edae4801ee96308fe03c305cf3c03babe8c45068c5987cf0de3d92ffef2991fe45c7a4600e05dbce5c0cbb9828f729d2345ac50844ff1436813218f59f73f05cc285ae82e61677bfa6f9586077c2fbaa009ad3b68e51e954560ecd2cb621b901f2ef024069e971b9507b80467484d68047cc96ebe05fe2094ac89abc5df9bdca0f0d0fff0ec51fc94bc8186800ab8367dae68ff9c23a4528ca7f68b174e45b40099af1ebd500b308285f0364911dda308b6d986c29673f3c98fe9d73bce2c093191cebfc59a3a0f163471d3099a53a8b9fd9163110cf2ce4a6bbcdc106e47ff2cfc56e94724ace9445824eec1c0f232e196baf3b3beba4236a2a70533116a010e8f0d9cd67ecbadad65985c444513cec91e556d835ef9e7dd497e193796313f077196402ee22e35a2d40a07fbfe34769b3e02d2132f695b74fa22cbaa5d39a9db75750c010e52fe0cff242fab55447da1403cb9060ca31899a677","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"0b9764b4abd8dd64745fd2410607bcb8"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
