<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7e41d022644750c967044c2ac5ec8acefde9bd648ab41575233695c8397464c4ea5b49ee3c3eff75016351322e26b2c6d696d56a95639a34d373d8d7fd24007f504b0acd68507273e635c7a2640cc96808573b9f21e445ff79bc631b08041b7195bbc7c324107b692aa2284d5019e75ec1e710333be3340f50562e8ac3a53e48cbc0c7bcc042fd858ce10eb62ea91478353d8aee89c892f73863ed3c66fb7c42aa947e83e632cb9a719bb3c366887b1dc1498103400287b1fdecbdd73aa0bda58eba7b615b5899c379b3dbe78311ba2c6fdaff568a449ab6e0fa1bdecbe475dc099c570f433776433fa3425e36b50db903c4141918978aa8f3f783bbd04d307c57c32c5d15adddec51aa07e462bbe4cbd8a0e1d4d1cf2244b3689705e7623bf32b328db15b87f1184e82126e5d0b1dd35c8b20d83de6d4d5fb0795ee7345084fadec6d305e86a70ed8101506d9499cc3e69052ff64e0489e45eeab3136c949d640f322d9200b43acfb58e496754b39bebc5b709e6e092595357e8b61b01e06f0ae1bf067c5815ea254d526e2e8731275fde014d607716adc961a33b75522f8190100ccb84160e8c0b771676725b0012330e2d1ac324b1e1c29f20ab518fd2377f2480124c8fb91219249c1bab6c323f65654d7914f45c62f6f87cd96c77e60ac96971283835047230de5828c1d6bbb8950c9b97dcc7b5204600da7559aba1218cd548498dde02cde2f5ad4a3fe2aa647ee69849784f3f784060ef6f1f843d3ebd45c440d5eca8dba12b2b0b35071850f30febb73414fd3b4c62f54cb948ac804753801a3d0b0bc04dfc3d28aeda61663bc29d94d8645f25673c4f47b1c4010adbb510de0e3fbb2ece1a127b911a6d49030fb4dcbec0aecde1923ba5e48d38ad94c5a4c2e20fe87bdfb571227a5211b469ebf70135077798779592e67b724370db28d70849703541ec23fb23daa71cbc62b097c1eb1a497da7f899c4afe759b327863d2162791456f01ece40b78d5469ce753fbc2b43abefe5f50023bbf057c15d2909b0b5b5dbf812ee4468e6f7a3816027be97418c0b7d04e1c2ca073a98a7a6e866f4de1039007950e5f0994d7b06c41bb8cc3d1911c144f0183de9dbe955405e51fbda34bab10733b7daa62cca3989fcf1100038e5eae886dc1c5358256028c08b3368b1da1cb02225fb6a8b634260a53cdb46168f394bf8fcdf90beca66802d71da6dcba24845f0a3427bf115f938a9e999d79ac4f0db0f42ea979bdf67e5859ddbbd82040e0acd3618fad71a6cacbc0ee29493aae71f2b03bcbad4a2a84effec20624bbb3c722673c633e9a8f12fe1e91fded4cf267f5573a94a099a8cb675e4d4cfb701ea404ab0d0eb7ee96307cafb0d680e51950cbdf50907ee5d56d8c260c0da3ff33a38b1582cfd669aee489e0193f634a5b65fd3e1873f91dfeb1ba3c9c7940fdd34a06e55de26d24a01e5328abb50ce65413366c858750c50cda936c0a2a30f9d9ed2a61c8a7c3fac28ae36da9a91fd4b5070c4500f9a0bdf8c406b7d7456df3a0304d24cce6fa24eb80d4f9bcb9e9c9cbcc29bc46d9289f2372a24fcf89161c2f92fb1e05419e1605bf4ad733f53af3171863e0222b95a715fb73b95ba05a257a8f935f94e778d71858b74eb05d9e5442ee0d6025cd4c0dee53419d40584206942e00fbd179bdbc7f93eca8fbc357be56a2df51486dcd4ae87d130c43f80819b9f7ec42a0079df7cf5ab7be07e7c2f8ff9cbb2c767f0a09f74e62920d78d352123a7a879f8ed1259a17e4d5f4c0130ae35d261fabaec016233e779221fdd64c3d2ce21119feaf65ea59a11b85416c885eb31c3818039cdfa9350a7d3a7a4fac42f5198a293098c987671586543f783a5cf5b7a60b6cb1df49707fc7db241f7d3991bb349b2343ba55b48c8b98c003c2158ce38ddc28841c79d45a086e54249ac0129ce677159057c43d58713ec9cd2932d9b5b2314c7bdaf49326590c79f030a417512fefcab8b5a8990cae693f78c1eea2e18c7246a09ca05e097ac67465f125f28ded79b38adcc9bafb97c07fc5de0a2f86155c7462464b79a52f8afe8f2d665e2905c389f3805e3d94f3953ee304869f57269c5689280578a0ea4db46bbbb2e26893c683074ec0760b84f8c9c79ca5b1c21d23945db7e6966639cfb60cb48920c59e41086c15160458d912ea5279a3b00124d0be739258217d16ecdd71954b2365829f32fed89288859a4493442f37ef43231599862f03d15eeb31fd192ee5ef5a100976555e3414dbfe5c4710651d05072b6e33bd93c522e87a4452e7e1da2e6e61b4c137a76ba07894fe357190e6449c43959a6302b0a7b856bc6330aeafce19fa4389492dbac82d4eb6c51ad1de18913c36dd8c969c6b9b48171808c0839a6bdc452edbeb2044b9735011b1f8c2f01914830d75a43e70537abe7c9aebd6962a32e73ef99240b5c9817e5c1eab52e1e0cd2fdb6347a2d0dd0cf422c1fccaa41267c504c20e978a58ff6572e7afe74b466b2a78657061d9c6efbf42f33a7e5a38def73eea7391d37fa251195d16bf63b8f527d9401873d2358dd7253ef03f398c7094fd152e7309b66b3ccb3640ac9f72595d63692a8fe63f4f23ecdf1f8846b3813bdc413f9e0ff22e7011e724e90208255dd9a7851ac497defcf5768837daedcfd1ad1cf465dbee21fe7220a8c802f37de5eedf917b9314f0acb58a468870ca2a703b6e6b3f89927807518c2d5d7844a3929223d642194bee526f4a0effd46fa6a840e1e46128ca778cf9a6a53273e355a6004a7bf76634a569bf468212b47597a839a99407088129b996d80ef9888d39df8a6d9f9657b1280f4998deafdac4ff9e378efdc4461b8aceb11c81a978b80520af2bfc0581b1286ec3900d23e7b073549ada041ae73de0c7c1b69ee1da2a88c39ca2c60eba0d607a58798ad8da714882aeb7127b4faf09eb17600dd125ccc0a5d43616d4d217f28621d4f30b4008c9b47fb8fb4d8be9bfca2eb3ce7477a4f2c06709aca686d4740be7d43449f25cf6d62dd12cda251863440ec9af691d18b5e0cf231fca9e956104bde5725bffe64cd5c663979265d7e2d6a91c1b23144c18d011c3c0439998ab708bd93a18a9312dd468fae0e01daa229b71c58a7902f3292eb0ae83ace1c88f98e99874bb8257516e4bf5ca768703da967d2f3d770b901a18845249f92de6f84d203bdb8470e50c95622e113edec0083e80bfac13329da9ac9c7dcf7a6249283f4f21c6b7b6d4ec8cbcb87f8b103740fb347d9b662d65e37937ee3d1f981d1c731b3afd86b965ccfe7964f8905f5757c414b3ca04d316020f3cb3148d62e59b9fb53994a3e12e085acfeaf790dcc3f1d27b742d392e3b95b52c3d0150a375ea7fa6873c06762aef0b28c8bbb52ff11b69600b53c8c21917263b4307e97871349a4e34b50550d4b1a065af9615b0e2356f83dfb0c6a9a379d9c177cd414bdc700d9b87c08f7ba1a2b8b6fe070724d4b84dd4172df4b4c0343529d3ea3a44ae900073e94c9ccea71c96b531d21b1f6390502fa76ba41537aa51685e00933a76e20dc3225de549f2dfed0a8957cddedca2556ac8ea7b0217967101e52498298103775cd72338f3d62b7b998ca3448e9fc9ea0a61cefb20353837c257a1c53f9ee84437a1ade4522437425bc407e7bcbc7b02887a8e2c8e22ed1b655d2cb197fc887611c04307a885d20753c6e38223cc98a08d7a87607bd5b55af4a25f5e0e7c26de3392a3d7073b391a6ea5b4cff41dc2b3bdb01c6ba16a4ac76d5a62d1250de792d5109f7b066ea9bd10ed9d6e3622cceb3274e0d7ea9c4237daaa81f377c03a03736fc313d44bce6acd47867da3bf29a3b7d280798e93fc7c0c7fc4421aead52bc8ba61d247be82e54fe54f623761a11da0b8c6e8f6c617858c07600121beb8c17b5379c7047cb33259f9fa26c991d6d892bb72dcc41a52215391810f5e448c34b04a83af797a6a571245fee48a24ec46f47f8087f5ec1e7401c6adb5717cfee48d65ce5cd944d7ee3a4fc9a84cca92ed787198655aeff07bc10b0d10b87cf95d9eda7c3425f954d7dcec2141807b78ba22d5f209d67d46f8ef7f2394d5f775696805c6bbe7194d516ed74f46b0ee9d41ae089107405b92361a906e13d86f1c3b9130c87cfa9cbb5d0838631a085aad4caffbdd23b9a4a8a0d54fd4317325465eefcd17d2c24ca8db3c1ce50d1981fcd197c6d66e513621d6b243ea1814e56c786c26892389e9cc3aaa582499a7243b05855136fa4201145ec4480087b59e8a60bd09e3468e05e6de09253c12a6c940aeebb9ed9fe58347e995ace5dddc72679537872e29d9fb471dacae22b6abb975d438dc106ec7ae2ae29081fe129659e3b7d55e0a1a5549ffbb8c45e8abaad99c8e428e6196d3ea0a19df39ad14ad5deff8187b49185938b4db441c16dde6739126af5e7bf085b2d60d1f8b08340e2781ae31fa076c2d13062b7f13b2a8e6f807c7230b3da14efc2ebe228feefc7a2a7e17287849be5af26262cf0973740d54593901430e17e70ae8e934197cd76d3badd6f986e237306aa846dfa049b55de53ff949235b5594d5f4b34124a7d2d59e2fdb45517c81f74c888cd5f4abee4f8eb238e9792becb7132e9ae6e953279b3d9fc4a58d0e177d66fa57e3b63f86a36a011b8758aec11af00612042e9fb69f1a4c18580e5bffcf09fd7a1fc72d3906d24f689f74a3fefd14cb132b69172d1fdb26f5064fd802070f271068f1a1cb737175b81795d540e8030d1dd3da1730740809f327e24e7f7f15076e2d4dc73fee42abff86c815902141f3463ff81ed0b892df421c4dc5badb1f62ec0423cb724e23e0711121ec2e39df70c7d4f69992675dcd216255553976243e67bdbc8ca4c9a5e0c4738c51c028df15382a60fb578c8806b668ebec8179cab53b36bc1c8b6284c3318fb549ef3c376bee90652948555354d71042afc1b7330740016b55256f2e6d305fac5aaac7372fe7b4ef3ffc6600f64916536a98a1e7ea406deae05d35064ff4aa1ce65b712af51c690545c8928a930ca1a01dd41c873e5cd635870f343db7f28816e9fecb4b472d0587fa56ee1adf5d02ffbe0233d0d390aebce6aee553acd824dc6cf42d4a26c7a6e99d4d28f7754671eca22c9773810806456b5ef381f3991959a0955fe771bcf619376acd1715fd331329f797e04e0777b03b9409382447c22708bce6784e0de265d843528b39d7c2e5ed28cbc4635fa846ca30f27fdf06e593061ef36a9e1ba565fe0a7abaaa2d4a4dbe676b2cb26db4dc106b987fb3d4b3633cf5de92dc027dcbcbd76734bafb74d86b19300bd2ed16658c24c14a80048f2c1e702cc0104fd061b7bfb3efca316e0d42ade9d08aed1bd556cc3c1b23e374cb99e47be96eb53b62e90f65645b14ddbed386390748e9328cb478cef486bdaae3b420b48b37b636a90bd1b9e27dd498329215323c250c013e9271b9f6aa60304c1170c12b5ec6f804f390b91f42434709b4b6338d0e7348f79224d5db7c38acb5f5cfe5e00c965a6464d6575dfc05e9bb0a288aa0e5754b489054f8ed56b3d1e936f96cabd17845697458911cb6abc6c19fc381df305511b0fe7e0e1d028b53d00a8e8b7e44cc6526f3b154db8e5cd68f68a75626f06132d59aaf8323f01a1505054949f0b1fc74257f84242c4eaf6cfaf739f076dd4d982ad6ab9bb5946e2f0ffecaf3e8ff7b03a1c0941b15aadd83b3c5cc8cad7c0a440ad649c9d0d55139c906fe2151a95e4645cfbcb6868e4d7f9566c3d236edd9d3d78e2af8a5bc19a78f7c24d8e3023a3e5aa5e105d4b9f257c0ec90e770d993c99e2bcd551a0f0dea9f5583b1ec8922de0f1c939179a55006e49f57355adf469b1e0efa39d154400caf0ad270747e1cb18c7a5ea4b2a0a85b5b297c17e70415000c1425f6b204053b9087b61b821984d114222809abbb2e0bb709b284a58e7b4ec14ae043fde25d589862cdec9e24d24db807ef81c1a825bc9e1f1fd6862a7a5a26227b673350b36a14851c54f7d12234f132bee605fe9a833f0904f859888e9f25a618da2e2ba1d07a44d3c9dfe6e3b7ef9f5e0020bff2aeba19c48ef6a55e37dc214d0930abcf23ee12ab89c52082baca518dea1811d43e63314d98909b42c54fd6989a8ee0b05eb597d98f6a27c414d8b9812b338b6cb4a16b5f9ac22b2aa97105da26b7797c6a02cc0fba64a81330530e1f462cc85798396dff94e249ac79cfdfd32937d7d5304272b3cb98e12c20de826dcd3c52a98ee1ef467af375fb5ddb90b6ebe08a0a9a53d63b99396fec56e395f6bca8caac6848e1ff1db7a7b0151ca55f7a38dd6e18697a8c0f977edb8e2cd5c0e43f66107df4976a9498304abdbe84ce9df4f6000637ba8fda2f4539409f33e94675b1516f3f851087a165696b861208301e4eed18dfce0619b3c6ea113670e0b5f250c7f40d18d2f466258105f219d3fa948ad70d64fc94f44b4d487d84423f3d5a52be683d7601cb71a6dc7acff502b0403b8c34a270eeba08b19c7fe3a26f069adfbd60938eb0e0c234051b77569c990fb31a845b723a1f0b88d5ff5de1867abb63e2da35083b19d96c5a809eab7d89a41b91f44bb230f8fd449f0317b5fe31331066ac1a64f16fe751def98b2af616f10e634a1b0122e2c2bc1d3b6f548ddcf257f32d49ba06d9d8989732086845c4f972af34e288852c4149e9cb4edeea4bd770bae47bbc77c7e37f56ce38f109de7aff035768ac820be1fe2029a7861b02e40d5c193259bb01edff1a6a5aa157ad7e5862bf1d5e83a5ee3631c8492ecaa488bc7ef1e3a6ea9ef900f659784ef45c7dd3c3ee7d71efd20518d63d459e5ac1f90fd651e45e72063c18e250d93ac80971c5f792982a2be7e5064ad02d6b360105a047c1895b416ca0225ff8170132bedcab14caa95e5db2ca298ac9400c3b6443d529924237aa7180a30e5b90f4dc11e5a4d964e1674d3af93b250a1862c2965a568c6c58e2960afef94de33c9e07f41627d64fbc1c0ec66987ef3675c1d8a63d1e05458816d04d03cc169837d56ecfffb7c9e3e5fb16732cd9943a2ff77998675257c5f0c970d9d34629163244608781d13ea14a142cc0a112df86aaeec700311826f5e9b57d88f1c04ca12bc7989bac8758e95f16e4b5427b9fe6d040c4f2885ed8cc1cf125c9ecfa8d2ce872b6fd4bb77514dab5fc40a1622ca52a87f98682162d94927c5c78cf5aea57a8f8f9903bd99f391d35c12797ca2945ff87a9a7b2ac8b378d38861871c93d03961818e0ba507afbd8f886031959586701c03f77b790b4d9d4d7530a04da56d552939d4a84bf5b7f2ae764767c9d48bd882361f4e28cea6cdb181d04b26da708793faa2105c95ca7b8ce5a08f5795cfaffe1989f926b2aacac2fe9faf3512d77c1b7f9be313462806bda7769ea659b6ff4af3f7a5275f04025dede2aea0a70c71883300a712f31c6ab8f4f43dccb39d490e983b9cbc0cf52bf2ecbc385e69959d711db1ccb540076167f4a6163114d5a56d4a8b0ef66e72e3694e7d0a323696d8f580f82a3d6bf0a48e8458903f62a95a5db75add0e63874f3224de99002dea82a566aefc83bd7bf7dd4e3c81e9f2eec5adb2906b8d0c6fb80db9494c86000a725641f0f6b83d435a85c763b92ec10d0d98c075f4e07cdd05dbba9bb38b06abb780acce4e3c66572f1bd28c5cb46ba28384571df4f65c03a6d1d5f28afc11e8461cca241e826545bc90969ce16c727efc10f438f44f13dd365073f480d9e7e7b592d345ebe1764bc915792cb8d6c0e8decc45c6ff606d4baaed3fe693cfb2baf2dbc74e36a6fd9a09d881edffed42c08e4d8739f67f7c03258119b34317d74b9e64132259b4d119ff7170f038e92eab4bcfc16b1ef2652fd8b1f5976839ea047029ce18797e3fe93047a0fc4d84c88fa75510f10dd6555a5496a80d54c71c36fe5cc6c9e0b55ec8d2ddce07a4e19dfd2da8343123e98b73f3c51c097f6ea66e3afd12dcc82836d397d06d379f5a6f6e968ef6d458ab99e5b2d641c5eab3d44f321175f07d06a25366694aa05b193042e7cc9e4b0d8ffd07f8e38d37e1a85157a1dbad43f443e785599f814ac9b6d123fec41a45fe9ccdb594fad89fe0482724ba8f5c847edaa27bcd215820e0cf1b1c1c7dd6fb3ef26d9a5018b7471250c14aa088462dc3a3f65549b1e790609e061193d9ccb67a32eb55d32a1296add7db2dcbb20300e0eb1f20fd29fde78a51d8d0609f5ee8d434462c5741d7da75c6026630582e0bc2df59003b759d863614977e611efcd2b91cccf83f6ee4621b8c45d3595db15466992e6e9f44bc66dfdd60425d012b4500e3ce5db4cc180fc8cac6f7eadfe584252fe168a3fe6584c4f699e91127bb1c074a0bc3cd4ad4f3a03d4fe0b00abd6b05c82a343219a7c3bf52f0cd2ba89e63b5b34a61592235b043f315b24936c6a1f2e64f72b9129c1979e00f35830a8b058133ffba404fb48e41b6e0d74da05b3e687a66b027db5a868910698c5379ebdad32dc1615b812afea2191ed3a56d3c3096b964ff772b58ab899bf920403d177ff961e4f45924efa04867ac90685bdd7ad6b366e908a15de7455e259246139babbf6bf80c51889760e091702d845d1a42c830fd6c97b819756a8c6e0032274ecf7c723a0384db9c28ee95b558cdde6727842a810f133ca8fb19358050488453f7f56174ec88282e8b810f832ad6d175cde9bbecc348de3558165fc380cac5130aadd3dfc453e1dac59279d9898596b8c980ece7515a3796beea6709bf99c3d66909f7c0be7c5622b317181d6d071c0e2874eedbb36d2fae037d6ea70499c080b65277f8589ff6d4167ec8c2629e2e247a8401e3b22467646b203452d916c08e25136cdca3ecf6dd98616482a51a344e9b14f1f1ac019c72e2b3b0e4449b0d0619bcc2898e5cd7e00f56758ed6345abf9e165a878bcca2a5cecd2836b1322c253b1515963022676b02c2246e48787053aa9ff7d847e6bc104e82cd102d25af66b55f1c6d73a4622d8d4a4a0b9096235c5d7798b35bbaf60701240b1029442bbb085ff9a965a039034aae4f55cd384d45fd715f5f77e66887231ae4a745d9749b9b552cc3a5d22e77ea631b91356a9d7c0123ace5365683071220cd3d0365629a90aed506406238e7e0c7ecf5b1c42bc6cf18f63d8433c8348d2a4a96213f795729b4aa2b2111a5aeda2dd0ad1015bd8dc409307fe8e9948e8a723efcaca1eef5f083ce948ad2bef19d9d8901e1c495f74e953c55cbd06a241ef5738b077bd3fe66bf2d2dab896214674296df8a993fd8ebda27ddb52da2013746d21723a3cbf8da98d2e0c4e11cb98edf16cdbfa80caa7c83afcb971e1011955aa3cb8c3701f546c0bde67b2473dccfd5344c95b4ccbb07de122c267a796bf5424a24b09043bb2da5b2a624eae80a8663fff2b951fc94f618239a14307b781774eceec919f6dd3a555f86a6508c5f848996238f859591102542f682b707513b659c3ac9549beb5045a4658872c317a8e65be75d3bd7d3370d358f14b8a58fc9a5fb6c1d3b5a7d608a61384e977fe7cdb293c43bb3e86ddc6139c0cb99b191f6db3a0cf645ad6b65c963c8f88a189796a7fe8c663130c3200c8350d8c553bc2a2f169c281545e45827d5fb665ca22c6ce8d3b0a947813491b010edbb26a57bcc563f4d060b0b6a069e23f434264cd0ae00c6b0c443c2b1cc1ee87ddc97cd2f42cb4bd16fa41fdf502f44ce7bd5931adde505c168f2aa13740c08ae4a2b870231a11ae36a36eff2fd58d7d3c311e3bc8103026bb56fd486c993693e6b3681e91899ca121296973d211a82ab8a0a0afa5f31699c61b9840aa3d9ad6845fb983c8eecb5dcc75a583a6e1a74b8dbd49f345d8303a447fb249c7421dfeb4835414b367ddf709c490c0c6c8d774376036729f13c1c1c3371e2b3b71d408c3cce332c2bf09598e8f391c7f487170b3643a968720aa66516a6af32e559a85d5bb5692cf15ae44929f657bbe31c57780d59e76bbcd535bdf32a74b3572dd54f884a01868750fe3b102cdf77655a1b3bb7c08ea5368b8736bb9a10720d2ee9a38f070276788382fb418cee27b57bb4de0f183a063093c55f2deb3bf7e278b84cccb935b2cb3b4a438769fd52ebea9c81032f26e15f53c71bdc2034c7b814ff98cc2502f47de7cec55afb3ea22c1b6b0820c043cf5257cef449dd6ea7774dd7923ae72f91f0bd217c425769c42236f5bababf59955383b5347e5964c4e8ffa0569fb1e2eede9694b97c07e48bd9102871fe696202b1e3979e14c4d295b49665e423ad5a3f10859a36562d8f219be9acf4bd62bc2061a71fbdc0f1bd0f527413f874ded466efad532f0290a23a9c4139de59f935889b149f1c603067329f00f37d2a558fc8ddd5acaf48c7fa586a6558c0ebf31e0bb52ebff0b8f6f36fd2efea0ccaac7acaa4b8cb3cc9284c2e48cacddbb5f8fe4e75170a67092b4e5c11319e0ed6a80936f7905d658e846400b0bc314c4355e1b16c874bf244dadfb3fc74edee81c9328cbe705e19359a365b51c1b518128d237cae859ff7adccf56e254ea3393f8a95d67cd671bfb6aa34995897d86159062998df208140ac751b4ac73846951169d5e41db73a17fd73b641cf907ddf56f5a96ba94f6174e8b50c065d9aeba9dd96783ca569cb70743743fcbb9432b829f0b8e2e2c480c08fde4e61accbe65b3f6fe0f0167fe0e6e339f4a5a212742d9bf82c41d4042c6442f0a880f331416f9a5d084115b35bf3219923986a7d36cac5d81018edac41d8c7acdd3f8dad9e5e919e5a382e21d5588be3f16d4f7834f62dc4b3a753041789e29100748a6ce5840355e969651c944e59ac10fe5f5b799fd4a00efc5d3e7246dc713c76f5ac31422f4fdbef1088ddf46ae82f7efde4b33ddca8c80f769b1564d58f6d670b2f99701f9368547487d60ffddf8fffce60b9388deac517c846761cf31be312d311299070103b23e8b53efab8cf566009807bc6707ca0934d0311e8d82c4b8844815fbfc3ce671973ef803b853b067a95b3fca1148d6e6d4bc2f37d80149f19f12e0780a58032530936958789ed8f7f64aa196f2c99164496cc6d9d4536396a91120aac1ff4048616174ee4ead6ae8b93733342fd0be999ac1b50702e3aae96d9cadf2c6406fbc5b651e0ac232fc59d01603e6acbdbcd58c3f829b98beea69f96c0e08aa257f1f3f2d3da4ad4914ff459eabfc0f426e950a38d9d0a5cb228a308e1cfd26493eeaf5c5ac6162ca3c233130fd46e3f2a6c4726ea5c7272720a450cfaedd97ad12166f9e345fa5231f68aa0d0dd312ae5ebd5dde59bcccf072ef75ec45afc7a5cd577b9f6c0f711b706931f26c72e91648f21bd25362e4a6c3d3c09c6d93ecb12557c18b621783a516ef696fae2cd3c2acff1041bbd517b0d7efe26a92ed73142e00b9579438801eb1aaa5d95d491f7f3e320e4098b747e8655e0db04e42ff67c430acefe163235fbb86f2f84bd276471ce64fe7cebe640214965335ffd18167e4c59f8bd62ff3f3661b065e030513afc678753b0f4e2eff21256870ede815ac60d5e8a00f640e1ba9c2855cbcd4beb6f0e064f3992fe9283c24bb9fe97fc735111b40c8775e66c2a4e29b7fcd78cee5d392179d4677805d54c1150640afd853a56238b419a4695675553f13e3b739e2d0b8518b7130c0bd3318fa2d441721d65863b9d2b3be6c7242cc555ec4440f6988d1e9346137ba0c28b2ab1c0abaabccfd70b3247af697655b255436e5dbb12d3cbfbc59eedd5dad769b3fc5b7cab88e19b8598b71e0db836392b72762e1e29a1097a43553ad6cd59760334af6888028e9db1d9c20523d605c2acfb2acfbe8da2262538ab59192aa313f46db047522ba8a7a7015b2567c33b430d75cec8bb8079b7d6306a0d51a378cf747ee7c298cf9c0333a5e644b2ddf53c067045dba951de608f40408036e802ffc71ca0ede7bcee85d3299539813a0e32411e6966af9f0000fa653f87f7597f8406c2df808b5554a742ba1f438f3f26b1f954555f0b39d371a934d20ba84d3288bbd6df590f878ea52197a7e432def0bc0daeacc52b88a3b0a32d819aa734263efe905c6a448be1638097777ad87f4d943666ca7401f82db82a4a58f6c521c56a2ee291742237e9b821021aab99b264f2d1315986667d57e63ccb9d9c247b99d1ec1af6076614f2bf291b594a453276a396f9e32165369dea73bebced9d965598fbf48208c20d6fa747ee192d92e57c86b7ebd7ce1ccc73a75bbf1a512d214d7b2bb3f5f3bd24e4eb6dd355b07201452778e61eee60f58d00f1c09a82fc23dd92f4626ccb85383c6411551eed3f77ff7844d9e85ea26b8d1663c604c1752ef6ab78d0f3595cd307a945d4323eae3db66250c1e1b522f51ed6036c78e527c82713c971d42d74acab84fd7a047e2a3b916cd59003d300b6424145de5f57580fb950c27b201fa8980be36b640091d6e87a9ddb1445771d91cf0f9fe4df9afce20ff60db044480e27b575e742d6aa07dbf3ea480b08fc88172a283eda0d7eed8bea382d6f057dda0de8ceed1de7922e8d736120343946970366fff4c9c1ab233ee8992c8d4267fea4176e70314a89fbcb21f93809eef3cd93a58a1d0adaccc776e0303acacf0a174cd06d12fa67d9057292fa101a1cb32a0d961cc532a74fa03bd5489574c457d81c3961a6afe833d86431aed872bb222f3b304b987039107c5861f4d78009b5e12d9136caa026efaaf08c8e03d3142a3770c8494c603dc627ce604c9c65aa74e621ddc8b1cfeab1c466a66d7c9fb0e697de169aa46ca942a9a63822c75a5e69bcbfd621532393cdfb1420b89581e023781f81b0148ff0041d863c27c41cee2d6d433a5b86a0b5740df1f9641d5191d9bf8394952bda8722617be95124efb7498dcc0a90a0ce8f89a6e7cd7d711c9f649801cef55b9a0cbf9462ea381c8af850a2aa30c981cdec2400d2491a27758183646ec2faa7f52bba431e7acb1f0536c41f138afe93b8d82c41b0dbda2de36ae9e2a646dc9624da473ea259a1fd0b1e25104081a0081158c5575a6e1fdb721b465affb846631a644c8e841cb3912786603f5795885d8f6af78ef3ce0cef062ad5c292d67a11159193eebf4865333f3d027ae05213571b943a75a7b7d2877ec084b2f9a5bc48bf74410f33c38c8ad17c03d99b608af32b8d2e141a594a9ec95b4cc182e9644628745118a022bb41059f57308349e305622ebf0798bdd2e184da5cf5521eb3517b1646511c799803d3bbe68fe9185eb61820f7cc6abd5e5cc5c8dcf40b339a117e592fe0e9a51ac61b81ecf81a10e8b9e7b095235dea379c3c99dc9dd67f4594d15ff4bc0f54d101fa4dc913bd4c0e2199ce57f14e99c863bc7c8df412c9a1cbaeda50054ef99df4fb7a19b387a8e63311ddc501c5a0b6ad5296ab2243eba9dae7c7e502163f7075326f217e53ee19f835a47006bd994af9c3b0b69c2abece503ee6cffc07d90e7de870c6517254592f65f965a1f5143073d797d7d0ff4902049bbcc8eb2a4c4f1c49985b6d051fc963baa648de727c74bdc040a6a3722822486486f32580243bea91799823cdb33c79a850788d23d77cc820e06f41361c2c705c227baadbe2b53b61182c5f321b951ffb967dd5da8c086a5072a588640ac7ee4db374150f4384e82a84e7f798b32e3d0e911713bab16f7087ef553644cec43d9bd25b36121ae6bbde3f58fe33a978886d575dc0a6c77d40a0cb8bf2d7bc7cd2cf1caf1c43aaa1317ebf6d1d3bea519820682d73b70891783ba5f731d2d2e212a910aa9afe3085924eeae51aad2b755dc7d5a2a508ea2d9925ae028ad5c497a0c315c32dbf367ed9a0f1361fe0ad41ce6769426ceb9de0182a5d5e1b9d3a645836fc84967cdc613dff2eb5e62c9587c816aa24e2912ec4138e1128b49fd3c2a712c8b85ece1d6f140a9031da10027220a24a5b9359112e54ed53b3c56b3cf92ee26401438965b3bc3ec94f2276760c0751829cdfc2f2386caf3fd13b7655cbe3188dfedef217bc8b121b6d7bfa4a2523c4900cba5371026f1380f66330e936f3f488961a41d6f3b63e5d3255a3056d2558b48b0b7a15aeb80d64ea6822a3dce6f2fc7c1d325880755b8352a9ee952d91b0f04f194ddc4efa0899beef930c51b5f3d6d74669f9678431e2d0bf3aff135390ff6e6b4b20c921c6ce89964bd034aebd190875222dd52e6a8167fdf1d61b5fde857335114a9239284684dccb7b7f2bd630d0cef2ca063094249c0d92aebaf4bc7787c05bb076c0dea7f452ed7d44874f3f7c7ec7efb3bc3c46a688e7325e7c6337ebddb7ad570e85b1961a0dae3bee64ba2304502c49747e91523fc5c8cfff38e3c24cfd2fe0e99947f62ba6d31e91c1ccd7ec735ca4932df0dc642e980dce2b1465b12b9678e74487ff9515a456a2a725b45feeaa2061b0aa0a56cfaf4b9bec75aff7ec726653524757dac6078522cce38c29791efa212226b022027c4f545d347719d1be9021ace92c1a110ef93f2985808ec3e57fcf2bb2fdeaf759674fd5fa6d0b061a83a1b0fdca094ad4a4c5f54866acbc84d35659dd91a10f625f172a1891d965b83ba1d4b40e2e3f9461fb386518241d3612dfcfcb30129b84754c474825a266bbbd7501b4770c04239fcee89c4a0d4fe993214bbf0421ad5b12e7e73357ff3912c84ab3bda55fc2c41ebcc63f264d5348dabbd69aa650f9887c951b9b33957517b9dc4da6c85b129b06b1ff850fda0fc822e02d862ececd256bca55eb4fde5cb508692fbc8c355887d7bc73af85ef108c788c911e89fddfba1174d8d923069d412e9eacd71309935593e8beaf883159ac0238c10f91e42c032687cae2a13a2b47c3a841678a4b46e999240b938b96c96ac5b8a81782c5a7a92f727f92d87da5de97201363e0ab7fcb4411823d45f3211973467fd805a37f533d2eae908cb8a5b141aa0e829a11f989c64bb6ebf131575c9229ff00e5789ba16eed3af7d857a605efb3e12a73dbfd902637863bc1f5817944bebffa5595c3ff77d056f3fc56cf8eb9573677b108e4147fd3aaf4c0694adeac75bcedc4bdac7bff4e48866d368f87529eec53289898139b6ba6cb1c930cc48977a2d52634a12afba2d47a7774251c3c6d35f307d3845ff0c31b3e3811e67b91866ef5011164786fa6173df11c7c2473b8bf2d5afa6a91dbe2f25858986dded61e3b32d34f26a1c02ddba612b8efb06f83b15011dc0f7c0658a5e79915575f407f0dee91730d023ac2c42c23898ba1e13be995400be60a4460f8436311f78b3a2115e80a17c723147a9b2afc60d3fedf52fca0a3c59449979ee54484463ac546d308bc8d1b5906c124cd58517e94e5b77f3f94ce93976f28dca424aaea3a1855db8692409d72776ef6f1555510b952fc855c200d0587ffd052078eff34339f0bde2feb00ef4b72f6d233e93508664b0d86aedc49242528b2885e4864decd4d7f8dfb6dc2d382700028b12c2869a0e559e1bd3ef80bd65b5d8e71dc366165b7222d3ccbb5c5e7404f5018c51fe985ab4f92e2798106685c7faa50bd809f42f4dc8b0bd6f3f654d6141bdb5f10df4c480761a7d543d6d54256018b817a929e3370b564ececdcca61575ccd37f13da13f1205dce15b66c99267be84ff3d643bb4b2f7b19b48a575766eeb54f785773a6d5d41787680f76ccfd43d481c51c78478b8f053424f3c8a257f80209202814c0e7b7a9aa9fa563ac05973924e439baa42c0f010e15ea20ae8e2ced3ac68665341004fd88729eeeef3024901feabe971e49887f3c7fea16ebfa6e63c7d1d5ecde17cb3aeec05659ebef1904cb638c59001ceb502579a82a56c383dd02de97dc98aed97d379dc1159837a2255ac9d5e2678394b55142043ee4e967ca8c8f84975e67e522dc","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"0b9764b4abd8dd64745fd2410607bcb8"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
